pipeline {
    agent any
    
    parameters {
        string(name: 'IMAGE_TAG', defaultValue: 'latest', description: 'Docker image tag to deploy')
        choice(name: 'ENVIRONMENT', choices: ['dev', 'staging', 'prod'], description: 'Deployment environment')
    }
    
    environment {
        AWS_REGION = 'us-west-1'
        EKS_CLUSTER = 'dev-CP-EKS-CLUSTER'
        ECR_REGISTRY = "${env.ECR_REGISTRY ?: 'ACCOUNT_ID.dkr.ecr.us-west-1.amazonaws.com'}"
        ECR_REPOSITORY = 'sqs-processor'
        NAMESPACE = 'sqs-processor'
        DEPLOYMENT_NAME = 'sqs-processor'
    }
    
    stages {
        stage('Checkout') {
            steps {
                echo 'Checking out code...'
                checkout scm
            }
        }
        
        stage('Configure kubectl') {
            steps {
                script {
                    echo 'Configuring kubectl for EKS...'
                    sh """
                        aws eks update-kubeconfig --name ${EKS_CLUSTER} --region ${AWS_REGION}
                        kubectl version --client
                        kubectl cluster-info
                    """
                }
            }
        }
        
        stage('Verify Image') {
            steps {
                script {
                    echo "Verifying image exists: ${ECR_REGISTRY}/${ECR_REPOSITORY}:${params.IMAGE_TAG}"
                    sh """
                        aws ecr describe-images \
                            --repository-name ${ECR_REPOSITORY} \
                            --image-ids imageTag=${params.IMAGE_TAG} \
                            --region ${AWS_REGION}
                    """
                }
            }
        }
        
        stage('Get Infrastructure Values') {
            steps {
                script {
                    echo 'Getting SQS and S3 values from Terraform...'
                    dir('enviroments/dev') {
                        sh """
                            export SQS_QUEUE_URL=\$(tofu output -raw sqs_queue_url 2>/dev/null || terraform output -raw sqs_queue_url)
                            export S3_BUCKET_NAME=\$(tofu output -raw s3_bucket_name 2>/dev/null || terraform output -raw s3_bucket_name)
                            export AWS_ACCOUNT_ID=\$(aws sts get-caller-identity --query Account --output text)
                            
                            echo "SQS_QUEUE_URL=\${SQS_QUEUE_URL}" > ../../sqs-processor/infra-values.env
                            echo "S3_BUCKET_NAME=\${S3_BUCKET_NAME}" >> ../../sqs-processor/infra-values.env
                            echo "AWS_ACCOUNT_ID=\${AWS_ACCOUNT_ID}" >> ../../sqs-processor/infra-values.env
                        """
                    }
                }
            }
        }
        
        stage('Update Kubernetes Manifests') {
            steps {
                dir('sqs-processor/k8s') {
                    script {
                        echo 'Updating Kubernetes manifests with infrastructure values...'
                        sh """
                            # Load infrastructure values
                            source ../infra-values.env
                            
                            # Update configmap
                            sed -i "s|<SQS_QUEUE_URL>|\${SQS_QUEUE_URL}|g" configmap.yaml
                            sed -i "s|<S3_BUCKET_NAME>|\${S3_BUCKET_NAME}|g" configmap.yaml
                            sed -i "s|us-west-1|${AWS_REGION}|g" configmap.yaml
                            
                            # Update serviceaccount
                            sed -i "s|ACCOUNT_ID|\${AWS_ACCOUNT_ID}|g" serviceaccount.yaml
                            
                            # Update deployment with new image
                            sed -i "s|image:.*|image: ${ECR_REGISTRY}/${ECR_REPOSITORY}:${params.IMAGE_TAG}|g" deployment.yaml
                            sed -i "s|<ECR_REGISTRY>|${ECR_REGISTRY}|g" deployment.yaml
                        """
                    }
                }
            }
        }
        
        stage('Create IAM Role') {
            steps {
                script {
                    echo 'Ensuring IAM role exists for service account...'
                    dir('sqs-processor') {
                        sh """
                            source infra-values.env
                            ROLE_NAME="sqs-processor-role"
                            
                            # Check if role exists
                            if ! aws iam get-role --role-name \${ROLE_NAME} &> /dev/null; then
                                echo "Creating IAM role..."
                                
                                # Get OIDC provider
                                OIDC_PROVIDER=\$(aws eks describe-cluster --name ${EKS_CLUSTER} --query "cluster.identity.oidc.issuer" --output text | sed -e "s/^https:\\/\\///")
                                
                                # Create trust policy
                                cat > /tmp/trust-policy.json <<EOF
{
  "Version": "2012-10-17",
  "Statement": [
    {
      "Effect": "Allow",
      "Principal": {
        "Federated": "arn:aws:iam::\${AWS_ACCOUNT_ID}:oidc-provider/\${OIDC_PROVIDER}"
      },
      "Action": "sts:AssumeRoleWithWebIdentity",
      "Condition": {
        "StringEquals": {
          "\${OIDC_PROVIDER}:sub": "system:serviceaccount:sqs-processor:sqs-processor",
          "\${OIDC_PROVIDER}:aud": "sts.amazonaws.com"
        }
      }
    }
  ]
}
EOF
                                
                                # Create role
                                aws iam create-role \
                                    --role-name \${ROLE_NAME} \
                                    --assume-role-policy-document file:///tmp/trust-policy.json
                                
                                # Create and attach policy
                                POLICY_ARN=\$(aws iam create-policy \
                                    --policy-name SQSProcessorPolicy \
                                    --policy-document file://sqs-processor-iam-policy.json \
                                    --query 'Policy.Arn' \
                                    --output text 2>/dev/null || echo "arn:aws:iam::\${AWS_ACCOUNT_ID}:policy/SQSProcessorPolicy")
                                
                                aws iam attach-role-policy \
                                    --role-name \${ROLE_NAME} \
                                    --policy-arn \${POLICY_ARN}
                                
                                rm /tmp/trust-policy.json
                                
                                echo "IAM role created successfully"
                            else
                                echo "IAM role already exists"
                            fi
                        """
                    }
                }
            }
        }
        
        stage('Deploy to Kubernetes') {
            steps {
                dir('sqs-processor/k8s') {
                    script {
                        echo 'Deploying to Kubernetes...'
                        sh """
                            # Apply namespace (if not exists)
                            kubectl apply -f namespace.yaml
                            
                            # Apply configmap and service account
                            kubectl apply -f configmap.yaml
                            kubectl apply -f serviceaccount.yaml
                            
                            # Apply deployment
                            kubectl apply -f deployment.yaml
                        """
                    }
                }
            }
        }
        
        stage('Wait for Rollout') {
            steps {
                script {
                    echo 'Waiting for deployment to complete...'
                    sh """
                        kubectl rollout status deployment/${DEPLOYMENT_NAME} -n ${NAMESPACE} --timeout=300s
                    """
                }
            }
        }
        
        stage('Verify Deployment') {
            steps {
                script {
                    echo 'Verifying deployment...'
                    sh """
                        echo "Pods Status:"
                        kubectl get pods -n ${NAMESPACE} -l app=sqs-processor
                        
                        echo "\\nDeployment Status:"
                        kubectl get deployment ${DEPLOYMENT_NAME} -n ${NAMESPACE}
                        
                        echo "\\nConfigMap:"
                        kubectl get configmap -n ${NAMESPACE}
                    """
                }
            }
        }
        
        stage('Health Check') {
            steps {
                script {
                    echo 'Performing health check...'
                    sh """
                        # Wait a bit for pod to be fully ready
                        sleep 10
                        
                        # Get pod name
                        POD_NAME=\$(kubectl get pods -n ${NAMESPACE} -l app=sqs-processor -o jsonpath='{.items[0].metadata.name}')
                        
                        echo "Testing health endpoint on pod: \$POD_NAME"
                        kubectl exec -n ${NAMESPACE} \$POD_NAME -- curl -f http://localhost:8080/health || true
                    """
                }
            }
        }
        
        stage('Send Test Message') {
            steps {
                script {
                    echo 'Sending test message to SQS...'
                    dir('sqs-processor') {
                        sh """
                            source infra-values.env
                            
                            echo "Sending test message to SQS queue..."
                            aws sqs send-message \
                                --queue-url \${SQS_QUEUE_URL} \
                                --message-body '{"test":"deployment","build":"${BUILD_NUMBER}","timestamp":"'"\$(date -u +%Y-%m-%dT%H:%M:%SZ)"'"}' \
                                --region ${AWS_REGION} || true
                            
                            echo "Test message sent. Check logs in 30 seconds:"
                            echo "  kubectl logs -n ${NAMESPACE} -l app=sqs-processor --tail=20"
                        """
                    }
                }
            }
        }
    }
    
    post {
        success {
            echo 'CD Pipeline completed successfully!'
            echo "Deployed image: ${ECR_REGISTRY}/${ECR_REPOSITORY}:${params.IMAGE_TAG}"
            echo "Environment: ${params.ENVIRONMENT}"
            
            script {
                sh """
                    echo "\\n=== Deployment Summary ==="
                    kubectl get all -n ${NAMESPACE}
                    
                    echo "\\n=== Next Steps ==="
                    echo "1. Monitor logs:"
                    echo "   kubectl logs -n ${NAMESPACE} -l app=sqs-processor -f"
                    echo ""
                    echo "2. Send test message:"
                    source sqs-processor/infra-values.env
                    echo "   aws sqs send-message --queue-url \${SQS_QUEUE_URL} --message-body '{\"test\":\"message\"}' --region ${AWS_REGION}"
                    echo ""
                    echo "3. Check S3:"
                    echo "   aws s3 ls s3://\${S3_BUCKET_NAME}/sqs-messages/ --recursive"
                """
            }
        }
        failure {
            echo 'CD Pipeline failed!'
            script {
                sh """
                    echo "\\n=== Pod Logs ==="
                    kubectl logs -n ${NAMESPACE} -l app=sqs-processor --tail=50 || true
                    
                    echo "\\n=== Pod Events ==="
                    kubectl get events -n ${NAMESPACE} --sort-by='.lastTimestamp' || true
                """
            }
        }
        always {
            cleanWs()
        }
    }
}
